<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SmexyMap - GPS Visualization Tool (Deck.GL)</title>
    
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Load deck.gl correctly with specific versions -->
    <script src="https://unpkg.com/@babel/polyfill@7.12.1/dist/polyfill.min.js"></script>
    <script src="https://unpkg.com/deck.gl@8.8.27/dist.min.js"></script>
    <!-- Add MapboxOverlay for improved deck.gl integration -->
    <script src="https://unpkg.com/@deck.gl/mapbox@8.8.27/dist.min.js"></script>
    
    <!-- MapLibre for base map -->
    <script src="https://unpkg.com/maplibre-gl@^2.4.0/dist/maplibre-gl.js"></script>
    <link href="https://unpkg.com/maplibre-gl@^2.4.0/dist/maplibre-gl.css" rel="stylesheet" />
    
    <!-- D3 for easing functions -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Montserrat:wght@600;700&display=swap" rel="stylesheet">
    
    <style>
        /* 
         * =====================================================================
         * SIDEBAR CONFIGURATION - EASILY ADJUST THESE VALUES
         * =====================================================================
         * These variables control the sidebar and toggle button positioning:
         *
         * --sidebar-width: Width of the sidebar (320px default, 280px on mobile)
         * --toggle-width: Width of the toggle button (24px)
         * --toggle-offset: Distance the toggle button extends outside sidebar
         *
         * TO ADJUST THE TOGGLE BUTTON POSITION:
         * 1. Change --toggle-offset to a positive value (e.g., 10px) to make
         *    the button stick out more when sidebar is collapsed
         * 2. This will make the toggle button more visible and accessible
         * =====================================================================
         */
        :root {
            --primary-color: #2998ff;
            --primary-dark: #1e78cc;
            --secondary-color: #2ecc71;
            --secondary-dark: #27ae60;
            --accent-color: #e74c3c;
            --point-color: #3498db;
            --current-point-color: #ff6b00;
            --dark-bg: #2c3e50;
            --light-bg: #f8f9fa;
            --text-light: #f8f9fa;
            --text-dark: #333333;
            --shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
            --border-radius: 8px;
            --sidebar-width: 320px;
            --toggle-width: 24px;
            --toggle-offset: -20px; /* ADJUST THIS VALUE to change how far the toggle button sticks out */
        }
        
        /* Map background */
        #map {
            background-color: #f8f9fa; /* Light background matching overall theme */
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Roboto', sans-serif;
            color: var(--text-dark);
            background-color: var(--light-bg);
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        /* Layout Components */
        #app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        
        /* Header Styling */
        header {
            background-color: white;
            color: var(--primary-color);
            padding: 15px 20px;
            box-shadow: var(--shadow);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 1000;
            border-bottom: 1px solid rgba(0,0,0,0.05);
        }
        
        .app-title {
            font-family: 'Montserrat', sans-serif;
            font-weight: 700;
            display: flex;
            align-items: center;
        }
        
        .app-title h1 {
            font-size: 1.8rem;
            margin-left: 10px;
            color: var(--primary-color);
        }
        
        .app-subtitle {
            font-size: 0.9rem;
            opacity: 0.9;
            margin-top: 3px;
        }
        
        /* Main Content Area */
        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
            width: 100%;
        }
        
        /* Sidebar */
        .sidebar {
            width: var(--sidebar-width);
            min-width: var(--sidebar-width);
            background-color: white;
            box-shadow: var(--shadow);
            z-index: 900;
            display: flex;
            flex-direction: column;
            transition: transform 0.4s cubic-bezier(0.19, 1, 0.22, 1), min-width 0.4s cubic-bezier(0.19, 1, 0.22, 1);
            border-right: 1px solid rgba(0,0,0,0.05);
            position: relative;
        }
        
        /* 
         * SIDEBAR COLLAPSED STATE
         * When collapsed, the sidebar is translated to the left, but leaves room for the toggle button
         */
        .sidebar-collapsed {
            transform: translateX(calc(-1 * var(--sidebar-width))); /* Move entire sidebar offscreen */
            min-width: 0;
            margin-right: calc(-1 * var(--sidebar-width)); /* Push map over to fill the space */
            overflow: visible; /* Ensure the toggle button remains visible */
        }
        
        /* 
         * TOGGLE BUTTON STYLING
         * The button that shows/hides the sidebar
         */
        .sidebar-toggle {
            position: absolute; /* Positioned relative to sidebar */
            right: calc(-1 * var(--toggle-width)); /* Position from the right edge instead of left */
            top: 50%;
            transform: translateY(-50%);
            background-color: white;
            border: none;
            border-radius: 0 var(--border-radius) var(--border-radius) 0;
            box-shadow: 3px 0 8px rgba(0, 0, 0, 0.1); /* Enhanced shadow for better visibility */
            width: var(--toggle-width);
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1000; /* Higher z-index to ensure it's always on top */
            transition: background-color 0.3s;
        }
        
        .sidebar-toggle:hover {
            background-color: #f5f7fa;
            box-shadow: 3px 0 12px rgba(0, 0, 0, 0.15); /* Enhanced shadow on hover */
        }
        
        /* 
         * TOGGLE BUTTON POSITION WHEN SIDEBAR IS COLLAPSED
         * No need to change left position since it's relative to the sidebar
         */
        .sidebar-collapsed .sidebar-toggle {
            /* Left position is automatically maintained by being relative to sidebar */
            border-radius: var(--border-radius);
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
            box-shadow: 3px 0 8px rgba(0, 0, 0, 0.1); /* Ensure shadow is visible when collapsed */
        }
        
        /* Sidebar Panels */
        .panel {
            border-bottom: 1px solid #e1e1e1;
            overflow: hidden;
        }
        
        .panel-header {
            padding: 15px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: #f5f7fa;
            transition: all 0.3s ease;
            border-left: 3px solid transparent;
        }
        
        .panel-header:hover {
            background-color: #edf1f7;
            border-left: 3px solid var(--primary-color);
        }
        
        .panel.active .panel-header {
            background-color: #e6f0fa;
            border-left: 3px solid var(--primary-color);
        }
        
        .panel-content {
            max-height: 0;
            overflow: hidden;
            transition: all 0.4s cubic-bezier(0.215, 0.61, 0.355, 1);
            opacity: 0;
            transform: translateY(-10px);
            background-color: white;
        }
        
        .panel.active .panel-content {
            padding: 15px;
            max-height: 500px;
            opacity: 1;
            transform: translateY(0);
            border-bottom: 1px solid #f0f0f0;
        }
        
        /* Panel header icons */
        .panel-header i.panel-icon {
            margin-right: 10px;
            color: var(--primary-dark);
        }
        
        .panel-header .toggle-icon {
            transition: transform 0.3s ease, color 0.3s ease;
            color: #aaa;
        }
        
        .panel.active .panel-header .toggle-icon {
            transform: rotate(180deg);
            color: var(--primary-color);
        }
        
        /* Enhance the panel content children */
        .panel-content > * {
            margin-bottom: 12px;
        }
        
        .panel-content > *:last-child {
            margin-bottom: 0;
        }
        
        /* Data Input Panel */
        #csv-textarea {
            width: 100%;
            height: 120px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: var(--border-radius);
            font-family: monospace;
            resize: vertical;
            margin-bottom: 15px;
            transition: border 0.3s ease, box-shadow 0.3s ease;
        }
        
        #csv-textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.25);
        }
        
        .button-group {
            display: flex;
            gap: 10px;
        }
        
        .btn {
            padding: 8px 15px;
            border: none;
            border-radius: var(--border-radius);
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        
        .btn:active {
            transform: translateY(1px);
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        
        /* Controls Panel */
        .control-option {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        
        .control-option:hover {
            background-color: #f8f9fa;
        }
        
        .control-option input[type="checkbox"] {
            margin-right: 10px;
        }
        
        .control-option label {
            flex: 1;
        }
        
        .slider-control {
            display: flex;
            flex-direction: column;
            margin-bottom: 15px;
        }
        
        .slider-control label {
            margin-bottom: 5px;
        }
        
        .slider-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .slider-row input[type="range"] {
            flex: 1;
        }
        
        .slider-row input[type="number"] {
            width: 60px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        /* Map Container */
        .map-container {
            flex: 1;
            position: relative;
            height: 100%;
            width: 100%;
            overflow: hidden;
            z-index: 800; /* Ensure map is below the toggle button */
            background-color: white;
        }
        
        #map {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            background-color: #f8f9fa; /* Light background matching overall theme */
        }
        
        /* Map tools should be above all MapLibre and deck.gl layers */
        .map-tools {
            z-index: 950 !important;
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .tool-button {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--shadow);
            cursor: pointer;
            transition: transform 0.2s, background-color 0.2s;
        }
        
        .tool-button:hover {
            background-color: #f0f0f0;
            transform: scale(1.05);
        }
        
        /* Timeline styles */
        .timeline-container {
            background-color: white;
            padding: 10px 15px;
            box-shadow: 0 -1px 3px rgba(0, 0, 0, 0.05);
            border-top: 1px solid rgba(0, 0, 0, 0.05);
            z-index: 900;
        }
        
        .timeline-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .timeline-buttons {
            display: flex;
            gap: 8px;
        }
        
        .timeline-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: var(--primary-color);
            color: white;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .timeline-btn:hover {
            background-color: var(--primary-dark);
            transform: scale(1.05);
        }
        
        .timeline-btn:active {
            transform: scale(0.95);
        }
        
        .timeline-slider-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .timeline-slider {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(to right, var(--primary-color) 0%, var(--primary-color) 0%, #eee 0%, #eee 100%);
            border-radius: 3px;
            cursor: pointer;
            margin: 10px 0;
        }
        
        .timeline-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }
        
        .timeline-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }
        
        .timeline-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }
        
        .timeline-slider::-moz-range-thumb:hover {
            transform: scale(1.2);
        }
        
        .timeline-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            color: #666;
        }
        
        .timeline-select {
            padding: 5px 10px;
            border-radius: var(--border-radius);
            border: 1px solid #eee;
            background-color: white;
            cursor: pointer;
            font-size: 0.9rem;
        }
        
        /* Journey Summary */
        .summary-panel {
            background-color: white;
            padding: 15px;
            box-shadow: 0 -1px 3px rgba(0, 0, 0, 0.05);
            border-top: 1px solid rgba(0, 0, 0, 0.05);
            z-index: 900;
        }
        
        .summary-panel h3 {
            color: var(--text-dark);
            margin-bottom: 10px;
            font-weight: 500;
        }
        
        .summary-content {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        .summary-item {
            flex: 1;
            min-width: 150px;
        }
        
        .summary-value {
            font-size: 1.5rem;
            font-weight: 500;
            color: var(--primary-color);
        }
        
        .summary-label {
            font-size: 0.9rem;
            color: #777;
        }
        
        /* Button styles */
        .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }
        
        .btn-primary:hover {
            background-color: var(--primary-dark);
        }
        
        .btn-secondary {
            background-color: var(--secondary-color);
            color: white;
        }
        
        .btn-secondary:hover {
            background-color: var(--secondary-dark);
        }
        
        /* Point Visualization Styles */
        .point-label {
            background-color: rgba(52, 152, 219, 0.9);
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
            border: 2px solid white;
        }
        
        .cluster-icon {
            background-color: rgba(231, 76, 60, 0.9);
            color: white;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            border: 2px solid white;
            animation: pulse 1.5s infinite;
        }
        
        .cluster-icon-large {
            width: 40px;
            height: 40px;
            font-size: 16px;
            background-color: rgba(192, 57, 43, 0.9);
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        /* Toast Notifications */
        .toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 9999;
        }
        
        .toast {
            padding: 15px 20px;
            background-color: #333;
            color: white;
            border-radius: var(--border-radius);
            margin-top: 10px;
            box-shadow: var(--shadow);
            display: flex;
            align-items: center;
            gap: 10px;
            opacity: 0;
            transform: translateY(20px);
            animation: fadeInUp 0.3s forwards;
        }
        
        .toast.success {
            background-color: var(--secondary-color);
        }
        
        .toast.error {
            background-color: var(--accent-color);
        }
        
        @keyframes fadeInUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Popup Styles */
        .info-box {
            padding: 12px;
            font-size: 14px;
        }
        
        .info-box h4 {
            margin: 0 0 8px;
            color: var(--primary-color);
            font-size: 16px;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }
        
        .info-box ul {
            margin-bottom: 5px;
            padding-left: 18px;
        }
        
        .info-box details summary {
            cursor: pointer;
            color: var(--primary-color);
            font-weight: bold;
            margin: 5px 0;
        }
        
        .info-box details summary:hover {
            text-decoration: underline;
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            /* Override sidebar width variables for mobile */
            :root {
                --sidebar-width: 280px;
                /* Toggle width and offset remain the same */
            }
            
            /* No need for additional toggle position styles as they're managed by CSS variables */
            
            .summary-content {
                flex-direction: column;
                gap: 10px;
            }
            
            .summary-item {
                min-width: 100%;
            }
        }
        
        /* Fancy toggle icon animation */
        #toggle-icon {
            transition: transform 0.4s ease, color 0.3s ease;
        }
        
        .sidebar:not(.sidebar-collapsed) #toggle-icon {
            transform: rotate(180deg);
            color: var(--primary-color);
        }

        /* Loading overlay styles */
        .loading-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.4);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }
        
        .loading-overlay.active {
            display: flex;
        }
        
        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 6px solid #f3f3f3;
            border-top: 6px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }
        
        .loading-text {
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.8);
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Deck.GL specific styles */
        .maplibregl-popup {
            max-width: 400px !important;
        }
        
        .maplibregl-popup-content {
            padding: 0;
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: var(--shadow);
        }
        
        /* Custom tooltip for Deck.GL */
        .deck-tooltip {
            pointer-events: none;
            position: absolute;
            z-index: 9999;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 4px;
            max-width: 300px;
            font-size: 12px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        /* Point pulse animation */
        @keyframes pointPulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.5); opacity: 0.4; }
            100% { transform: scale(1); opacity: 1; }
        }

        .pulse-circle {
            position: absolute;
            background-color: rgba(255, 107, 0, 0.4);
            border: 2px solid rgba(255, 107, 0, 0.8);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            transform-origin: center;
            animation: pointPulse 1.5s infinite ease-out;
        }

        /* Point styles */
        .point-marker {
            background-color: var(--point-color);
            border: 2px solid white;
            border-radius: 50%;
            width: 12px;
            height: 12px;
            box-shadow: 0 0 4px rgba(0, 0, 0, 0.4);
        }
        
        .current-point-marker {
            background-color: var(--current-point-color);
            border: 2px solid white;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            box-shadow: 0 0 6px rgba(0, 0, 0, 0.6);
            animation: pointPulse 1.5s infinite ease-out;
        }
    </style>
</head>
<body>
    <div id="app-container">
        <!-- Header -->
        <header>
            <div class="app-title">
                <i class="fas fa-map-marked-alt fa-lg"></i>
                <div>
                    <h1>SmexyMap</h1>
                    <div class="app-subtitle">GPS Visualization Tool (Deck.GL)</div>
                </div>
            </div>
        </header>
        
        <!-- Main Content -->
        <div class="main-content">
            <!-- Sidebar -->
            <div class="sidebar" id="sidebar">
                <button class="sidebar-toggle" id="sidebar-toggle">
                    <i class="fas fa-chevron-right" id="toggle-icon"></i>
                </button>
                
                <!-- Data Input Panel -->
                <div class="panel active" id="data-panel">
                    <div class="panel-header">
                        <span><i class="fas fa-database panel-icon"></i> GPS Data</span>
                        <i class="fas fa-chevron-down toggle-icon"></i>
                    </div>
                    <div class="panel-content">
                        <p>Format: time,latitude,longitude (one point per line)</p>
                        <textarea id="csv-textarea" placeholder="0,35.211037,-97.438866
5,35.222366,-97.45298
10,35.261436,-97.47378
15,35.26264,-97.47451
20,35.26264,-97.47452"></textarea>
                        <div class="button-group">
                            <button class="btn btn-primary" id="plot-button">
                                <i class="fas fa-chart-line"></i> Plot Data
                            </button>
                            <button class="btn btn-secondary" id="load-zybooks">
                                <i class="fas fa-book"></i> Zybooks
                            </button>
                            <button class="btn btn-secondary" id="load-triplog">
                                <i class="fas fa-map-marked-alt"></i> Project 3
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Controls Panel -->
                <div class="panel" id="controls-panel">
                    <div class="panel-header">
                        <span><i class="fas fa-sliders-h panel-icon"></i> Visualization Controls</span>
                        <i class="fas fa-chevron-down toggle-icon"></i>
                    </div>
                    <div class="panel-content">
                        <div class="control-option">
                            <input type="checkbox" id="show-radius" checked>
                            <label for="show-radius">Show 0.5km radius circles</label>
                        </div>
                        <div class="control-option">
                            <input type="checkbox" id="highlight-short-distances" checked>
                            <label for="highlight-short-distances">Highlight segments ≤ 0.6km</label>
                        </div>
                        <div class="control-option">
                            <input type="checkbox" id="show-point-labels">
                            <label for="show-point-labels">Show point indices</label>
                        </div>
                        <div class="control-option">
                            <input type="checkbox" id="show-points" checked>
                            <label for="show-points">Show point markers</label>
                        </div>
                        <div class="control-option">
                            <input type="checkbox" id="cluster-visualization">
                            <label for="cluster-visualization">Highlight potential stop clusters</label>
                        </div>
                        <div class="slider-control">
                            <label for="cluster-threshold">Cluster threshold (km)</label>
                            <div class="slider-row">
                                <input type="range" id="cluster-threshold-slider" min="0.1" max="2.0" step="0.1" value="0.5">
                                <input type="number" id="cluster-threshold" min="0.1" max="2.0" step="0.1" value="0.5">
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Information Panel -->
                <div class="panel" id="info-panel">
                    <div class="panel-header">
                        <span><i class="fas fa-info-circle panel-icon"></i> Information</span>
                        <i class="fas fa-chevron-down toggle-icon"></i>
                    </div>
                    <div class="panel-content">
                        <p>This tool helps visualize GPS trip data and analyze stop patterns for Computer Science projects.</p>
                        <p>Features:</p>
                        <ul style="padding-left: 20px; margin-top: 5px;">
                            <li>Load or paste GPS coordinates</li>
                            <li>Visualize trip paths</li>
                            <li>Identify potential stops</li>
                            <li>View point clusters and distances</li>
                            <li>Calculate trip statistics</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <!-- Map Container -->
            <div class="map-container">
                <div id="map"></div>
                    
                <!-- Map Tools -->
                <div class="map-tools">
                    <div class="tool-button" id="center-map" title="Center Map">
                        <i class="fas fa-crosshairs"></i>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Timeline Container -->
        <div class="timeline-container">
            <div class="timeline-controls">
                <div class="timeline-buttons">
                    <button id="play-button" class="timeline-btn" title="Play/Pause">
                        <i id="play-icon" class="fas fa-play"></i>
                    </button>
                    <button id="reset-button" class="timeline-btn" title="Reset Timeline">
                        <i class="fas fa-undo"></i>
                    </button>
                </div>
                <div class="timeline-slider-container">
                    <input type="range" min="0" max="100" value="0" class="timeline-slider" id="timeline-slider">
                    <div class="timeline-labels">
                        <span id="current-time">0:00</span>
                        <span id="total-time">0:00</span>
                    </div>
                </div>
                <select id="playback-speed" class="timeline-select">
                    <option value="1" selected>1x</option>
                    <option value="2">2x</option>
                    <option value="4">4x</option>
                </select>
            </div>
        </div>
        
        <!-- Journey Summary -->
        <div class="summary-panel">
            <h3><i class="fas fa-chart-pie"></i> Journey Summary</h3>
            <div class="summary-content" id="journey-details">
                <div class="summary-item">
                    <div class="summary-value">0.00 km</div>
                    <div class="summary-label">Total Distance</div>
                </div>
                <div class="summary-item">
                    <div class="summary-value">0 min</div>
                    <div class="summary-label">Duration</div>
                </div>
                <div class="summary-item">
                    <div class="summary-value">0.00 km/h</div>
                    <div class="summary-label">Average Speed</div>
                </div>
                <div class="summary-item">
                    <div class="summary-value">0</div>
                    <div class="summary-label">Total Points</div>
                </div>
            </div>
        </div>
        
        <!-- Toast Container -->
        <div class="toast-container" id="toast-container"></div>
        
        <!-- Loading Indicator -->
        <div class="loading-overlay" id="loading-overlay">
            <div class="loading-spinner"></div>
            <div class="loading-text">Loading map data...</div>
        </div>

        <!-- Tooltip container for Deck.GL -->
        <div id="tooltip" class="deck-tooltip" style="display: none;"></div>
    </div>
    
    <script>
        // Initialize the map when the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            // Show loading overlay
            document.getElementById('loading-overlay').classList.add('active');
            
            // Uncheck all visualization tools at startup
            document.getElementById('show-radius').checked = false;
            document.getElementById('highlight-short-distances').checked = false;
            document.getElementById('show-point-labels').checked = false;
            document.getElementById('cluster-visualization').checked = false;
            
            // MapLibre map styles - using Carto's Positron (clean white style)
            const MAPLIBRE_STYLE = {
                'version': 8,
                'sources': {
                    'carto-positron': {
                        'type': 'raster',
                        'tiles': [
                            'https://cartodb-basemaps-a.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png',
                            'https://cartodb-basemaps-b.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png',
                            'https://cartodb-basemaps-c.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png',
                            'https://cartodb-basemaps-d.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png'
                        ],
                        'tileSize': 256,
                        'attribution': '© <a href="https://carto.com/attributions">CARTO</a> © <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                    }
                },
                'layers': [{
                    'id': 'carto-positron-layer',
                    'type': 'raster',
                    'source': 'carto-positron',
                    'minzoom': 0,
                    'maxzoom': 19
                }]
            };
            
            // Initial map view state
            const INITIAL_VIEW_STATE = {
                longitude: -97.439,
                latitude: 35.211,
                zoom: 13,
                pitch: 0,
                bearing: 0
            };
            
            // Initialize the MapLibre map
            const maplibreMap = new maplibregl.Map({
                container: 'map',
                style: MAPLIBRE_STYLE,
                interactive: true,
                center: [INITIAL_VIEW_STATE.longitude, INITIAL_VIEW_STATE.latitude],
                zoom: INITIAL_VIEW_STATE.zoom,
                bearing: INITIAL_VIEW_STATE.bearing,
                pitch: INITIAL_VIEW_STATE.pitch
            });
            
            // Create deck.gl layers initially empty
            const layers = [];
            
            // Create a MapboxOverlay to integrate deck.gl with MapLibre
            const deckOverlay = new deck.MapboxOverlay({
                interleaved: true,
                layers: layers,
                getTooltip: ({object}) => {
                    if (!object) return null;
                    
                    // Format tooltip differently based on the object type
                    if (object.index !== undefined) {
                        // This is a point from the GPS data
                        return {
                            html: `
                                <div style="font-weight:bold;margin-bottom:4px;">Point #${object.index}</div>
                                <div>Time: ${object.time}s</div>
                                <div>Lat: ${object.latitude.toFixed(6)}</div>
                                <div>Lng: ${object.longitude.toFixed(6)}</div>
                            `,
                            style: {
                                backgroundColor: '#ffffff',
                                fontSize: '12px',
                                borderRadius: '4px',
                                padding: '8px',
                                color: '#333',
                                boxShadow: '0 2px 4px rgba(0,0,0,0.2)',
                                fontFamily: 'Roboto, sans-serif'
                            }
                        };
                    }
                    
                    // Default tooltip
                    return {
                        html: `<div>${object.name || 'Point'}</div>`,
                        style: {
                            backgroundColor: '#ffffff',
                            fontSize: '12px',
                            borderRadius: '4px',
                            padding: '8px',
                            color: '#333',
                            boxShadow: '0 2px 4px rgba(0,0,0,0.2)'
                        }
                    };
                }
            });
            
            // Add the deck.gl overlay to the map
            maplibreMap.addControl(deckOverlay);
            
            // Setup UI event listeners
            setupUIEventListeners(maplibreMap, deckOverlay);
            
            // Set up global map object
            window.map = {
                deckgl: deckOverlay,
                maplibreMap: maplibreMap,
                viewState: INITIAL_VIEW_STATE,
                gpsData: [],
                isPlaying: false,
                currentTimeIndex: 0,
                animationFrameId: null,
                playbackSpeed: 1,
                followDot: true,
            };
            
            // Add map bearing change listener in the map load event 
            maplibreMap.on('load', () => {
                console.log("MapLibre map loaded with deck.gl overlay");
                document.getElementById('loading-overlay').classList.remove('active');
                
                // Update current position on map move
                maplibreMap.on('move', () => {
                    // Only update if we have GPS data and a current position index
                    if (window.map.gpsData && window.map.gpsData.length > 0) {
                        // Get current position based on the current time index
                        const currentIdx = window.map.currentTimeIndex;
                        const lowerIdx = Math.floor(currentIdx);
                        const upperIdx = Math.min(Math.ceil(currentIdx), window.map.gpsData.length - 1);
                        
                        let currentPosition = [0, 0];
                        let currentHeading = 0;
                        
                        if (lowerIdx === upperIdx) {
                            // Exact point
                            currentPosition = [window.map.gpsData[lowerIdx].longitude, window.map.gpsData[lowerIdx].latitude];
                            
                            // Calculate heading if we have a next point
                            if (lowerIdx < window.map.gpsData.length - 1) {
                                const p1 = window.map.gpsData[lowerIdx];
                                const p2 = window.map.gpsData[lowerIdx + 1];
                                // Calculate heading between points
                                currentHeading = Math.atan2(
                                    p2.latitude - p1.latitude,
                                    p2.longitude - p1.longitude
                                );
                            }
                        } else {
                            // Interpolate between points
                            const fraction = currentIdx - lowerIdx;
                            const p1 = window.map.gpsData[lowerIdx];
                            const p2 = window.map.gpsData[upperIdx];
                            
                            // Linear interpolation between two points
                            currentPosition = [
                                p1.longitude + (p2.longitude - p1.longitude) * fraction,
                                p1.latitude + (p2.latitude - p1.latitude) * fraction
                            ];
                            
                            // Calculate heading from point to point
                            currentHeading = Math.atan2(
                                p2.latitude - p1.latitude,
                                p2.longitude - p1.longitude
                            );
                        }
                    }
                });
                
                // Add specific event listener for rotation changes
                maplibreMap.on('rotate', () => {
                    if (window.map.gpsData && window.map.gpsData.length > 0) {
                        const currentIdx = window.map.currentTimeIndex;
                        const lowerIdx = Math.floor(currentIdx);
                        const upperIdx = Math.min(Math.ceil(currentIdx), window.map.gpsData.length - 1);
                        
                        let currentHeading = 0;
                        
                        // Calculate heading based on current position
                        if (lowerIdx === upperIdx) {
                            if (lowerIdx < window.map.gpsData.length - 1) {
                                const p1 = window.map.gpsData[lowerIdx];
                                const p2 = window.map.gpsData[lowerIdx + 1];
                                currentHeading = Math.atan2(
                                    p2.latitude - p1.latitude,
                                    p2.longitude - p1.longitude
                                );
                            }
                        } else {
                            const fraction = currentIdx - lowerIdx;
                            const p1 = window.map.gpsData[lowerIdx];
                            const p2 = window.map.gpsData[upperIdx];
                            currentHeading = Math.atan2(
                                p2.latitude - p1.latitude,
                                p2.longitude - p1.longitude
                            );
                        }
                    }
                });
            });
        });
            
        // Setup UI event listeners
        function setupUIEventListeners(maplibreMap, deckOverlay) {
            // Sidebar toggle
            const sidebar = document.getElementById('sidebar');
            const sidebarToggle = document.getElementById('sidebar-toggle');
            
            sidebarToggle.addEventListener('click', () => {
                sidebar.classList.toggle('sidebar-collapsed');
            });
            
            // Panel toggles
            const panels = document.querySelectorAll('.panel');
            
            panels.forEach(panel => {
                const header = panel.querySelector('.panel-header');
                header.addEventListener('click', () => {
                    panel.classList.toggle('active');
                });
            });
            
            // Center map button
            document.getElementById('center-map').addEventListener('click', () => {
                if (window.map.gpsData.length > 0) {
                    // Center on the GPS data
                    const bounds = getBoundsFromGPSData(window.map.gpsData);
                    maplibreMap.fitBounds(bounds, { padding: 50 });
                } else {
                    // Center on default location
                    maplibreMap.flyTo({
                        center: [window.map.viewState.longitude, window.map.viewState.latitude],
                        zoom: window.map.viewState.zoom
                    });
                }
            });
            
            // Set up visualization controls
            document.getElementById('show-radius').addEventListener('change', () => {
                if (window.map.gpsData.length > 0) {
                    updateLayers(deckOverlay, window.map.gpsData);
                }
            });
            
            document.getElementById('highlight-short-distances').addEventListener('change', () => {
                if (window.map.gpsData.length > 0) {
                    updateLayers(deckOverlay, window.map.gpsData);
                }
            });
            
            document.getElementById('show-point-labels').addEventListener('change', () => {
                if (window.map.gpsData.length > 0) {
                    updateLayers(deckOverlay, window.map.gpsData);
                }
            });
            
            document.getElementById('show-points').addEventListener('change', () => {
                if (window.map.gpsData.length > 0) {
                    updateLayers(deckOverlay, window.map.gpsData);
                }
            });
            
            document.getElementById('cluster-visualization').addEventListener('change', () => {
            document.getElementById('follow-dot').addEventListener('change', function() {
                window.map.followDot = this.checked;
            });

            });
            
            document.getElementById('cluster-threshold').addEventListener('change', function() {
                document.getElementById('cluster-threshold-slider').value = this.value;
                if (window.map.gpsData.length > 0) {
                    updateLayers(deckOverlay, window.map.gpsData);
                }
            });
            
            document.getElementById('cluster-threshold-slider').addEventListener('input', function() {
                document.getElementById('cluster-threshold').value = this.value;
                if (window.map.gpsData.length > 0) {
                    updateLayers(deckOverlay, window.map.gpsData);
                }
            });
        }
        
        // Helper function to create bounds from GPS data
        function getBoundsFromGPSData(gpsData) {
            let minLng = Infinity;
            let maxLng = -Infinity;
            let minLat = Infinity;
            let maxLat = -Infinity;
            
            gpsData.forEach(point => {
                minLng = Math.min(minLng, point.longitude);
                maxLng = Math.max(maxLng, point.longitude);
                minLat = Math.min(minLat, point.latitude);
                maxLat = Math.max(maxLat, point.latitude);
            });
            
            // Add some padding
            const lngPadding = (maxLng - minLng) * 0.1;
            const latPadding = (maxLat - minLat) * 0.1;
            
            return [
                [minLng - lngPadding, minLat - latPadding],
                [maxLng + lngPadding, maxLat + latPadding]
            ];
        }

        // Parse the GPS data from the textarea
        function parseGPSData() {
            const csvText = document.getElementById('csv-textarea').value.trim();
            if (!csvText) {
                showToast('Please enter GPS data', 'error');
                return null;
            }
            
            const lines = csvText.split('\n');
            const gpsData = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                
                const parts = line.split(',');
                if (parts.length < 3) {
                    showToast(`Invalid data format at line ${i + 1}`, 'error');
                    return null;
                }
                
                const time = parseFloat(parts[0]);
                const lat = parseFloat(parts[1]);
                const lng = parseFloat(parts[2]);
                
                if (isNaN(time) || isNaN(lat) || isNaN(lng)) {
                    showToast(`Invalid numeric data at line ${i + 1}`, 'error');
                    return null;
                }
                
                gpsData.push({
                    time: time,
                    latitude: lat,
                    longitude: lng,
                    index: i
                });
            }
            
            if (gpsData.length === 0) {
                showToast('No valid GPS points found', 'error');
                return null;
            }
            
            return gpsData;
        }
        
        // Create and update deck.gl layers based on GPS data
        function updateLayers(deckOverlay, gpsData, options = {}) {
            console.log("Updating layers with", gpsData.length, "points");

            if (!gpsData || gpsData.length === 0) {
                console.warn("No GPS data passed to updateLayers!");
                return;
            } else {
                console.log("First point:", gpsData[0]);
            }
            
            const showRadius = document.getElementById('show-radius').checked;
            const highlightShortDistances = document.getElementById('highlight-short-distances').checked;
            const showPointLabels = document.getElementById('show-point-labels').checked;
            const showPoints = document.getElementById('show-points').checked;
            const clusterVisualization = document.getElementById('cluster-visualization').checked;
            const clusterThreshold = parseFloat(document.getElementById('cluster-threshold').value);
            
            // Get animation state if provided
            const animationState = options.animationState || { pulsePhase: 0 };
            
            // Get follow option
            const followDot = options.followDot !== undefined ? options.followDot : window.map.followDot;
            
            // Combine user options with control panel settings
            const settings = {
                showRadius: options.showRadius !== undefined ? options.showRadius : showRadius,
                highlightShortDistances: options.highlightShortDistances !== undefined ? options.highlightShortDistances : highlightShortDistances,
                showPointLabels: options.showPointLabels !== undefined ? options.showPointLabels : showPointLabels,
                showPoints: options.showPoints !== undefined ? options.showPoints : showPoints,
                clusterVisualization: options.clusterVisualization !== undefined ? options.clusterVisualization : clusterVisualization,
                clusterThreshold: options.clusterThreshold !== undefined ? options.clusterThreshold : clusterThreshold,
                currentTimeIndex: options.currentTimeIndex !== undefined ? options.currentTimeIndex : window.map.currentTimeIndex,
                followDot: followDot
            };
            
            // Create path layer for lines connecting GPS points
            const pathLayer = new deck.PathLayer({
                id: 'path-layer',
                data: createPaths(gpsData, settings.highlightShortDistances),
                pickable: true,
                widthScale: 10,
                widthMinPixels: 2,
                getPath: d => d.path,
                getColor: d => d.isShortDistance && settings.highlightShortDistances ? [255, 80, 80] : [41, 121, 255],
                getWidth: d => d.isShortDistance && settings.highlightShortDistances ? 5 : 2, // Make short distances thicker
                updateTriggers: {
                    getColor: [settings.highlightShortDistances],
                    getWidth: [settings.highlightShortDistances]
                }
            });
            
            // Calculate current position with interpolation for smooth movement
            let currentPosition = [0, 0];
            let currentColor = [41, 121, 255];
            let currentHeading = 0;
            const currentIdx = settings.currentTimeIndex;
            
            if (gpsData.length > 0) {
                // For smooth animation, interpolate between points
                const lowerIdx = Math.floor(currentIdx);
                const upperIdx = Math.min(Math.ceil(currentIdx), gpsData.length - 1);
                
                if (lowerIdx === upperIdx) {
                    // Exact point
                    currentPosition = [gpsData[lowerIdx].longitude, gpsData[lowerIdx].latitude];
                    currentColor = [255, 107, 0]; // Highlight current point (orange)
                    
                    // Calculate heading if we have a next point
                    if (lowerIdx < gpsData.length - 1) {
                        const p1 = gpsData[lowerIdx];
                        const p2 = gpsData[lowerIdx + 1];
                        // Calculate the angle between the two points
                        currentHeading = Math.atan2(
                            p2.latitude - p1.latitude,
                            p2.longitude - p1.longitude
                        );
                    }
                } else {
                    // Interpolate between points
                    const fraction = currentIdx - lowerIdx;
                    
                    // Use cubic easing for smoother transitions
                    // Linear interpolation
                    
                    const p1 = gpsData[lowerIdx];
                    const p2 = gpsData[upperIdx];
                    
                    // Smooth interpolation between two points
                    currentPosition = [
                        p1.longitude + (p2.longitude - p1.longitude) * fraction,
                        p1.latitude + (p2.latitude - p1.latitude) * fraction
                    ];
                    currentColor = [255, 107, 0]; // Highlight current point (orange)
                    
                    // Calculate heading from point to point
                    currentHeading = Math.atan2(
                        p2.latitude - p1.latitude,
                        p2.longitude - p1.longitude
                    );
                }
            }
            
            // Calculate pulsing size based on animation state
            // Make the map follow the current position if enabled
            if (window.map.followDot && window.map.maplibreMap) {
                window.map.maplibreMap.easeTo({
                    center: currentPosition,
                    duration: 50 // Short duration for smooth following
                });
            }
            const pulseSize = 15 + Math.sin(animationState.pulsePhase * Math.PI * 2) * 5;
            
            // Create pulsing effect around current position
            const pulseLayer = new deck.ScatterplotLayer({
                id: 'pulse-layer',
                data: [{position: currentPosition}],
                pickable: false,
                stroked: true,
                filled: true,
                opacity: 0.5,
                radiusScale: 6,
                radiusMinPixels: pulseSize, // Animated size
                radiusMaxPixels: 30,
                lineWidthMinPixels: 1,
                getPosition: d => d.position,
                getFillColor: [255, 107, 0, 80], // Semi-transparent orange
                getLineColor: [255, 165, 0, 120], // Orange outline
                parameters: {
                    depthTest: false,
                    blend: true,
                    blendFunc: [770, 771] // Standard alpha blending
                }
            });
            
            // Create current position marker (represented as a bigger point)
            const currentPositionLayer = new deck.ScatterplotLayer({
                id: 'current-position',
                data: [{position: currentPosition}],
                pickable: true,
                stroked: true,
                filled: true,
                opacity: 1.0, // Make it fully visible
                radiusScale: 6,
                radiusMinPixels: 8, // Smaller core
                radiusMaxPixels: 12,
                lineWidthMinPixels: 2,
                getPosition: d => d.position,
                getFillColor: [255, 107, 0, 255], // Bright orange core
                getLineColor: [255, 255, 255, 200], // White border
                parameters: {
                    depthTest: false
                }
            });
            
            // Create scatterplot layer for GPS points
            const pointLayer = new deck.ScatterplotLayer({
                id: 'point-layer',
                data: gpsData,
                pickable: true,
                opacity: 1.0,
                stroked: true,
                filled: true,
                radiusScale: 6,
                radiusMinPixels: 10,
                radiusMaxPixels: 16,
                lineWidthMinPixels: 2,
                lineWidthScale: 2,
                getPosition: d => [d.longitude, d.latitude],
                getRadius: d => 10,
                getFillColor: d => {
                    // Only highlight exact points (not interpolated positions)
                    const exactIdx = Math.floor(settings.currentTimeIndex);
                    return d.index === exactIdx ? [255, 107, 0, 250] : [52, 152, 219, 220];
                },
                getLineColor: d => [255, 255, 255, 200],
                updateTriggers: {
                    getFillColor: [Math.floor(settings.currentTimeIndex)]
                },
                // Add hover effect
                autoHighlight: true,
                highlightColor: [255, 255, 0, 200]
            });
            
            // Create layers array - order matters for rendering
            const layers = [pathLayer];
            
            // Only add point layer if points should be shown
            if (settings.showPoints) {
                layers.push(pointLayer);
            }
            
            // Always add the current position
            layers.push(pulseLayer, currentPositionLayer);
            
            // Add radius circles if enabled
            if (settings.showRadius) {
                const circleLayer = new deck.ScatterplotLayer({
                    id: 'circle-layer',
                    data: gpsData,
                    pickable: false,
                    stroked: true,
                    filled: true,
                    opacity: 0.08,
                    radiusScale: 1,
                    radiusMinPixels: 1,
                    radiusMaxPixels: 100,
                    lineWidthMinPixels: 1,
                    getPosition: d => [d.longitude, d.latitude],
                    getRadius: d => 500, // 0.5km in meters
                    getFillColor: [70, 130, 180],
                    getLineColor: [70, 130, 180],
                    parameters: {
                        depthTest: false
                    }
                });
                layers.push(circleLayer);
            }
            
            // Add text labels for point indices if enabled
            if (settings.showPointLabels) {
                const textLayer = new deck.TextLayer({
                    id: 'text-layer',
                    data: gpsData,
                    pickable: true,
                    getPosition: d => [d.longitude, d.latitude],
                    getText: d => `${d.index + 1}`, // Show 1-based indices
                    getSize: 16,
                    getAngle: 0,
                    getTextAnchor: 'middle',
                    getAlignmentBaseline: 'center',
                    getPixelOffset: [0, 0],
                    fontFamily: 'Arial, sans-serif',
                    fontWeight: 'bold',
                    getColor: [255, 255, 255],
                    background: true,
                    backgroundColor: [41, 121, 255],
                    backgroundPadding: [3, 3],
                    outlineWidth: 2,
                    outlineColor: [255, 255, 255]
                });
                layers.push(textLayer);
            }
            
            // Add cluster visualization if enabled
            if (settings.clusterVisualization) {
                // Find clusters of points based on threshold
                const clusters = findClusters(gpsData, settings.clusterThreshold);
                
                // Create a polygon layer for clusters
                const clusterLayer = new deck.PolygonLayer({
                    id: 'cluster-layer',
                    data: clusters,
                    pickable: true,
                    stroked: true,
                    filled: true,
                    wireframe: false,
                    lineWidthMinPixels: 1,
                    getPolygon: d => d.polygon,
                    getFillColor: [255, 105, 180, 100], // Soft pink/red color
                    getLineColor: [255, 20, 147, 200],
                    getLineWidth: 2,
                    parameters: {
                        depthTest: false
                    }
                });
                layers.push(clusterLayer);
            }
            
            // Log the layers before updating
            console.log("Setting DeckGL layers:", layers);
            
            // Update the layers
            deckOverlay.setProps({
                layers: layers
            });
            
            console.log("DeckGL updated with layers");
        }
        
        // Create paths for the PathLayer from GPS data
        function createPaths(gpsData, highlightShortDistances) {
            const paths = [];
            
            for (let i = 0; i < gpsData.length - 1; i++) {
                const point1 = gpsData[i];
                const point2 = gpsData[i + 1];
                
                // Calculate distance between consecutive points
                const distance = getDistanceFromLatLonInKm(
                    point1.latitude, point1.longitude,
                    point2.latitude, point2.longitude
                );
                
                // Determine if this is a short distance segment
                const isShortDistance = distance <= 0.6; // 0.6 km threshold
                
                paths.push({
                    path: [
                        [point1.longitude, point1.latitude],
                        [point2.longitude, point2.latitude]
                    ],
                    distance: distance,
                    isShortDistance: isShortDistance
                });
            }
            
            return paths;
        }
        
        // Calculate distance between two points using Haversine formula
        function getDistanceFromLatLonInKm(lat1, lon1, lat2, lon2) {
            const R = 6371; // Radius of the earth in km
            const dLat = deg2rad(lat2 - lat1);
            const dLon = deg2rad(lon2 - lon1);
            const a = 
                Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * 
                Math.sin(dLon/2) * Math.sin(dLon/2); 
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
            const d = R * c; // Distance in km
            return d;
        }
        
        function deg2rad(deg) {
            return deg * (Math.PI/180);
        }
        
        // Display a toast notification
        function showToast(message, type = 'info') {
            const toastContainer = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerHTML = `<i class="fas ${type === 'error' ? 'fa-exclamation-circle' : 'fa-info-circle'}"></i> ${message}`;
            
            toastContainer.appendChild(toast);
            
            // Remove toast after 3 seconds
            setTimeout(() => {
                toast.style.opacity = '0';
                setTimeout(() => {
                    toastContainer.removeChild(toast);
                }, 300);
            }, 3000);
        }
        
        // Initialize event handlers for the plot button
        document.addEventListener('DOMContentLoaded', () => {
            // Add event listener for the plot button
            document.getElementById('plot-button').addEventListener('click', () => {
                console.log("Plot button clicked, parsing GPS data...");
                
                const gpsData = parseGPSData();
                if (!gpsData) {
                    console.error("Failed to parse GPS data");
                    return;
                }
                
                console.log(`Successfully parsed ${gpsData.length} GPS data points`);
                window.map.gpsData = gpsData;
                window.map.currentTimeIndex = 0;
                
                // Update layers with new data
                console.log("Calling updateLayers() from plot button handler");
                updateLayers(window.map.deckgl, gpsData);
                
                // Center map on the data
                const bounds = getBoundsFromGPSData(gpsData);
                window.map.maplibreMap.fitBounds(bounds, { padding: 50 });
                
                // Update journey summary
                updateJourneySummary(gpsData);
                
                // Update timeline slider
                updateTimelineSlider(gpsData);
                
                // Force a redraw after a short delay to ensure everything renders
                setTimeout(() => {
                    console.log("Forcing redraw after plot");
                    updateLayers(window.map.deckgl, gpsData);
                    
                    // Check DeckGL state
                    setTimeout(checkDeckGLState, 250);
                }, 100);
                
                showToast(`Loaded ${gpsData.length} GPS points successfully`, 'success');
            });
            
            // Add event listener for the Project 3 button (triplog.csv)
            document.getElementById('load-triplog').addEventListener('click', () => {
                loadTriplogData();
            });
            
            // Add event listener for the Zybooks button
            document.getElementById('load-zybooks').addEventListener('click', () => {
                loadZybooksData();
            });
            
            // Add event listener for timeline controls
            setupTimelineControls();
        });
        
        // Load sample data for Zybooks
        function loadZybooksData() {
            // Check if map is initialized
            if (!window.map || !window.map.deckgl) {
                showToast('Map not yet initialized. Please try again in a moment.', 'error');
                return;
            }

            // Sample data points
            const zybooksData = `0,35.211037,-97.438866
5,35.222366,-97.45298
10,35.261436,-97.47378
15,35.26264,-97.47451
20,35.26264,-97.47452
25,35.265636,-97.47737
30,35.340107,-97.49224
35,35.41994,-97.48859
40,35.458927,-97.532814
45,35.46053,-97.63156`;
            
            // Set the CSV text to the textarea
            document.getElementById('csv-textarea').value = zybooksData;
            
            // Parse the GPS data
            const gpsData = parseGPSData();
            if (!gpsData) {
                showToast('Failed to parse Zybooks data', 'error');
                return;
            }
            
            console.log(`Successfully parsed ${gpsData.length} GPS data points`);
            
            // Store the data globally
            window.map.gpsData = gpsData;
            window.map.currentTimeIndex = 0;
            
            // Update layers with new data
            console.log("Calling updateLayers() from loadZybooksData handler");
            updateLayers(window.map.deckgl, gpsData);
            
            // Center map on the data
            const bounds = getBoundsFromGPSData(gpsData);
            window.map.maplibreMap.fitBounds(bounds, { padding: 50 });
            
            // Update journey summary
            updateJourneySummary(gpsData);
            
            // Update timeline slider max value
            updateTimelineSlider(gpsData);
            
            // Check DeckGL state after a short delay
            setTimeout(checkDeckGLState, 250);
            
            showToast(`Loaded ${gpsData.length} points from Zybooks sample`, 'success');
        }
        
        // Load triplog.csv data
        function loadTriplogData() {
            // Check if map is initialized
            if (!window.map || !window.map.deckgl) {
                showToast('Map not yet initialized. Please try again in a moment.', 'error');
                return;
            }
            
            // Show loading overlay
            document.getElementById('loading-overlay').classList.add('active');
            
            console.log("Attempting to load triplog.csv...");
            
            // Fetch the triplog.csv file
            fetch('triplog.csv')
                .then(response => {
                    console.log("Fetch response status:", response.status);
                    if (!response.ok) {
                        throw new Error(`Failed to load triplog.csv - Status: ${response.status}`);
                    }
                    return response.text();
                })
                .then(csvText => {
                    console.log('CSV data loaded, length:', csvText.length);
                    console.log('First few characters:', csvText.substring(0, 100) + '...'); // Log a snippet of the loaded data
                    
                    // Set the CSV text to the textarea
                    document.getElementById('csv-textarea').value = csvText;
                    
                    // Parse the GPS data
                    const gpsData = parseGPSData();
                    if (!gpsData) {
                        throw new Error('Failed to parse triplog.csv data');
                    }
                    
                    console.log('Parsed GPS data:', gpsData.length + ' points loaded');
                    
                    // Store the data globally
                    window.map.gpsData = gpsData;
                    window.map.currentTimeIndex = 0;
                    
                    // Update layers with new data
                    updateLayers(window.map.deckgl, gpsData);
                    
                    // Center map on the data
                    const bounds = getBoundsFromGPSData(gpsData);
                    window.map.maplibreMap.fitBounds(bounds, { padding: 50 });
                    
                    // Update journey summary
                    updateJourneySummary(gpsData);
                    
                    // Update timeline slider max value
                    updateTimelineSlider(gpsData);
                    
                    // Hide loading overlay
                    document.getElementById('loading-overlay').classList.remove('active');
                    
                    // Force a redraw of the layers to ensure visibility with a slight delay
                    // This helps ensure all marker circles are visible
                    setTimeout(() => {
                        console.log('Redrawing layers to ensure marker visibility');
                        updateLayers(window.map.deckgl, gpsData);
                        
                        // Check DeckGL state
                        setTimeout(checkDeckGLState, 250);
                    }, 500);
                    
                    showToast(`Loaded ${gpsData.length} points from triplog.csv`, 'success');
                })
                .catch(error => {
                    // Hide loading overlay
                    document.getElementById('loading-overlay').classList.remove('active');
                    
                    console.error('Error loading triplog.csv:', error);
                    showToast(`Error: ${error.message}`, 'error');
                    
                    // Try to check if the file exists by sending a HEAD request
                    fetch('triplog.csv', { method: 'HEAD' })
                        .then(response => {
                            console.log('HEAD check status:', response.status);
                            if (!response.ok) {
                                console.error('triplog.csv does not exist or is not accessible');
                                showToast("Error: triplog.csv file does not exist", 'error');
                            }
                        })
                        .catch(err => {
                            console.error('Network error checking for triplog.csv:', err);
                        });
                });
        }
        
        // Setup timeline controls
        function setupTimelineControls() {
            const playButton = document.getElementById('play-button');
            const playIcon = document.getElementById('play-icon');
            const resetButton = document.getElementById('reset-button');
            const timelineSlider = document.getElementById('timeline-slider');
            const playbackSpeed = document.getElementById('playback-speed');
            
            // Play/Pause button
            playButton.addEventListener('click', () => {
                if (window.map.gpsData.length === 0) {
                    showToast('Please load GPS data first', 'error');
                    return;
                }
                
                window.map.isPlaying = !window.map.isPlaying;
                
                if (window.map.isPlaying) {
                    playIcon.classList.remove('fa-play');
                    playIcon.classList.add('fa-pause');
                    startAnimation();
                } else {
                    playIcon.classList.remove('fa-pause');
                    playIcon.classList.add('fa-play');
                    stopAnimation();
                }
            });
            
            // Reset button
            resetButton.addEventListener('click', () => {
                if (window.map.gpsData.length === 0) {
                    return;
                }
                
                window.map.currentTimeIndex = 0;
                timelineSlider.value = 0;
                updateTimeDisplay(window.map.gpsData, 0);
                updateLayers(window.map.deckgl, window.map.gpsData, { currentTimeIndex: 0 });
            });
            
            // Timeline slider
            timelineSlider.addEventListener('input', () => {
                if (window.map.gpsData.length === 0) {
                    return;
                }
                
                const index = Math.floor((timelineSlider.value / 100) * (window.map.gpsData.length - 1));
                window.map.currentTimeIndex = index;
                updateTimeDisplay(window.map.gpsData, index);
                updateLayers(window.map.deckgl, window.map.gpsData, { currentTimeIndex: index });
            });
            
            // Playback speed selector
            playbackSpeed.addEventListener('change', () => {
                window.map.playbackSpeed = parseFloat(playbackSpeed.value);
            });
        }
        
        // Update timeline slider based on GPS data
        function updateTimelineSlider(gpsData) {
            const timelineSlider = document.getElementById('timeline-slider');
            const totalTime = document.getElementById('total-time');
            
            if (gpsData.length > 0) {
                const duration = gpsData[gpsData.length - 1].time - gpsData[0].time;
                const minutes = Math.floor(duration / 60);
                const seconds = Math.floor(duration % 60);
                totalTime.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            } else {
                totalTime.textContent = '0:00';
            }
            
            timelineSlider.value = 0;
            updateTimeDisplay(gpsData, 0);
        }
        
        // Update time display
        function updateTimeDisplay(gpsData, index) {
            const currentTime = document.getElementById('current-time');
            
            if (gpsData.length > 0 && index < gpsData.length) {
                const time = gpsData[index].time - gpsData[0].time;
                const minutes = Math.floor(time / 60);
                const seconds = Math.floor(time % 60);
                currentTime.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            } else {
                currentTime.textContent = '0:00';
            }
        }
        
        // Start animation
        function startAnimation() {
            if (window.map.animationFrameId) {
                cancelAnimationFrame(window.map.animationFrameId);
            }
            
            let lastTime = 0;
            let lastIndex = window.map.currentTimeIndex;
            
            // Create/reset any animation state
            if (!window.map.animation) {
                window.map.animation = {
                    pulsePhase: 0,
                    transition: {
                        active: false,
                        startValue: 0,
                        endValue: 0,
                        startTime: 0,
                        duration: 0
                    }
                };
            }
            
            function animate(timestamp) {
                if (!window.map.isPlaying) return;
                
                // Calculate time delta
                if (!lastTime) lastTime = timestamp;
                const delta = timestamp - lastTime;
                
                // Update animation state
                window.map.animation.pulsePhase = (window.map.animation.pulsePhase + delta/1000) % 1;
                
                // Update only if enough time has passed (for smoother animation)
                if (delta > 12.5) {  // ~80 fps
                    lastTime = timestamp;
                    
                    // Advance the time index based on playback speed and delta
                    // This ensures smooth animation regardless of frame rate
                    const increment = (delta / 1000) * window.map.playbackSpeed;
                    
                    // Apply smooth easing when transitioning between points
                    let newTimeIndex = window.map.currentTimeIndex + increment;
                    
                    // Ensure we don't exceed the data bounds
                    if (newTimeIndex >= window.map.gpsData.length) {
                        newTimeIndex = 0;
                        
                        // Set up a transition to smooth the loop back to start
                        window.map.animation.transition = {
                            active: true,
                            startValue: window.map.gpsData.length - 1,
                            endValue: 0,
                            startTime: timestamp,
                            duration: 500 // ms for transition
                        };
                    }
                    
                    window.map.currentTimeIndex = newTimeIndex;
                    const index = Math.floor(window.map.currentTimeIndex);
                    
                    // Only update visuals if we've moved to a new point
                    if (index !== lastIndex) {
                        lastIndex = index;
                        
                        // Update timeline slider
                        const timelineSlider = document.getElementById('timeline-slider');
                        timelineSlider.value = (index / (window.map.gpsData.length - 1)) * 100;
                        
                        // Update time display
                        updateTimeDisplay(window.map.gpsData, index);
                    }
                    
                    // Always update the map layers (for smooth interpolation)
                    updateLayers(window.map.deckgl, window.map.gpsData, { 
                        currentTimeIndex: window.map.currentTimeIndex, // Use the fractional index for smoother motion
                        animationState: window.map.animation // Pass animation state for visual effects
                    });
                }
                
                window.map.animationFrameId = requestAnimationFrame(animate);
            }
            
            window.map.animationFrameId = requestAnimationFrame(animate);
        }
        
        // Stop animation
        function stopAnimation() {
            if (window.map.animationFrameId) {
                cancelAnimationFrame(window.map.animationFrameId);
                window.map.animationFrameId = null;
            }
        }
        
        // Update journey summary information
        function updateJourneySummary(gpsData) {
            if (!gpsData || gpsData.length === 0) return;
            
            // Calculate total distance
            let totalDistance = 0;
            for (let i = 0; i < gpsData.length - 1; i++) {
                const point1 = gpsData[i];
                const point2 = gpsData[i + 1];
                
                totalDistance += getDistanceFromLatLonInKm(
                    point1.latitude, point1.longitude,
                    point2.latitude, point2.longitude
                );
            }
            
            // Calculate duration
            const duration = gpsData[gpsData.length - 1].time - gpsData[0].time;
            const durationMinutes = Math.round(duration / 60);
            
            // Calculate average speed
            const averageSpeed = duration > 0 ? (totalDistance / (duration / 3600)) : 0;
            
            // Update summary elements
            document.querySelector('#journey-details .summary-item:nth-child(1) .summary-value').textContent = `${totalDistance.toFixed(2)} km`;
            document.querySelector('#journey-details .summary-item:nth-child(2) .summary-value').textContent = `${durationMinutes} min`;
            document.querySelector('#journey-details .summary-item:nth-child(3) .summary-value').textContent = `${averageSpeed.toFixed(2)} km/h`;
            document.querySelector('#journey-details .summary-item:nth-child(4) .summary-value').textContent = gpsData.length.toString();
        }

        // Helper function to check deck.gl state
        function checkDeckGLState() {
            console.log("Checking DeckGL state...");
            
            if (!window.map || !window.map.deckgl) {
                console.error("DeckGL overlay not initialized!");
                return false;
            }
            
            const deckOverlay = window.map.deckgl;
            console.log("DeckGL overlay initialized");
            
            // Safely check for layers property
            try {
                const layers = deckOverlay.props?.layers || [];
                console.log("Current layers:", layers.length);
                layers.forEach((layer, i) => {
                    console.log(`Layer ${i}:`, layer.id, "with", layer.props.data?.length || 0, "data points");
                });
                return true;
            } catch (error) {
                console.warn("Could not access deck.gl layers:", error);
                return false;
            }
        }

        // Find clusters of points based on threshold
        function findClusters(gpsData, threshold) {
            const clusters = [];
            
            // Create a visited array
            const visited = Array(gpsData.length).fill(false);
            
            // Function to find all points within threshold distance from a point
            function expandCluster(pointIndex, clusterPoints) {
                // Mark this point as visited
                visited[pointIndex] = true;
                
                // Add this point to the cluster
                clusterPoints.push(pointIndex);
                
                // Check if any unvisited points are within threshold distance
                for (let i = 0; i < gpsData.length; i++) {
                    if (!visited[i]) {
                        const distance = getDistanceFromLatLonInKm(
                            gpsData[pointIndex].latitude, gpsData[pointIndex].longitude,
                            gpsData[i].latitude, gpsData[i].longitude
                        );
                        
                        if (distance <= threshold) {
                            // Recursively expand the cluster
                            expandCluster(i, clusterPoints);
                        }
                    }
                }
            }
            
            // Find clusters
            for (let i = 0; i < gpsData.length; i++) {
                if (!visited[i]) {
                    const clusterPoints = [];
                    expandCluster(i, clusterPoints);
                    
                    // Only consider clusters with at least 3 points
                    if (clusterPoints.length >= 3) {
                        // Extract coordinates for all points in the cluster
                        const coordinates = clusterPoints.map(idx => [
                            gpsData[idx].longitude, 
                            gpsData[idx].latitude
                        ]);
                        
                        // Create a convex hull from the coordinates
                        const hull = computeConvexHull(coordinates);
                        
                        // Add some padding to the hull
                        const paddedHull = padPolygon(hull, threshold * 0.2);
                        
                        clusters.push({
                            pointIndices: clusterPoints,
                            polygon: paddedHull
                        });
                    }
                }
            }
            
            return clusters;
        }
        
        // Compute the convex hull of a set of points using Graham scan
        function computeConvexHull(points) {
            // First, find the point with the lowest y-coordinate
            // If there are multiple, choose the one with the lowest x-coordinate
            let lowestPoint = points[0];
            for (let i = 1; i < points.length; i++) {
                if (points[i][1] < lowestPoint[1] || 
                    (points[i][1] === lowestPoint[1] && points[i][0] < lowestPoint[0])) {
                    lowestPoint = points[i];
                }
            }
            
            // Sort the points by polar angle with respect to the lowest point
            const sortedPoints = [...points].sort((a, b) => {
                // Calculate the polar angle
                const angleA = Math.atan2(a[1] - lowestPoint[1], a[0] - lowestPoint[0]);
                const angleB = Math.atan2(b[1] - lowestPoint[1], b[0] - lowestPoint[0]);
                
                if (angleA < angleB) return -1;
                if (angleA > angleB) return 1;
                
                // If angles are the same, sort by distance from lowest point
                const distA = Math.hypot(a[0] - lowestPoint[0], a[1] - lowestPoint[1]);
                const distB = Math.hypot(b[0] - lowestPoint[0], b[1] - lowestPoint[1]);
                
                return distA - distB;
            });
            
            // Remove duplicate points
            const uniquePoints = [sortedPoints[0]];
            for (let i = 1; i < sortedPoints.length; i++) {
                if (sortedPoints[i][0] !== sortedPoints[i-1][0] || 
                    sortedPoints[i][1] !== sortedPoints[i-1][1]) {
                    uniquePoints.push(sortedPoints[i]);
                }
            }
            
            // If less than 3 unique points, we can't form a convex hull
            if (uniquePoints.length < 3) {
                return uniquePoints;
            }
            
            // Build the convex hull
            const hull = [uniquePoints[0], uniquePoints[1]];
            
            for (let i = 2; i < uniquePoints.length; i++) {
                while (hull.length >= 2 && !isCounterClockwise(
                    hull[hull.length - 2],
                    hull[hull.length - 1],
                    uniquePoints[i]
                )) {
                    hull.pop();
                }
                hull.push(uniquePoints[i]);
            }
            
            return hull;
        }
        
        // Check if three points make a counter-clockwise turn
        function isCounterClockwise(p1, p2, p3) {
            return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0]) > 0;
        }
        
        // Add padding to a polygon by moving each vertex outward
        function padPolygon(polygon, paddingAmount) {
            if (polygon.length < 3) return polygon;
            
            // Calculate the centroid of the polygon
            let centroidX = 0;
            let centroidY = 0;
            
            for (const point of polygon) {
                centroidX += point[0];
                centroidY += point[1];
            }
            
            centroidX /= polygon.length;
            centroidY /= polygon.length;
            
            // Create a new padded polygon
            const paddedPolygon = polygon.map(point => {
                // Calculate vector from centroid to vertex
                const vx = point[0] - centroidX;
                const vy = point[1] - centroidY;
                
                // Normalize the vector
                const magnitude = Math.sqrt(vx * vx + vy * vy);
                const normalizedX = vx / magnitude;
                const normalizedY = vy / magnitude;
                
                // Scale the vector by padding amount and add to original point
                return [
                    point[0] + normalizedX * paddingAmount,
                    point[1] + normalizedY * paddingAmount
                ];
            });
            
            return paddedPolygon;
        }
        
        // Add cubic easing function for smoother animations
    </script>
</body>
</html> 